# Search
## 37.Sudoku Solver
### variables
- rows: a list of defaultdict, for dictionary rows[row_idx], record whether key 'num' in the dictionary
- columns
- boxes
- solved: nonlocal boolean, whether solved
- board (given)
(rows, columns, boxes need to be initialized according to the table using place_num())

### functions
- could_place(d, row, col)
check if d can be placed at (row, col)
-place_num(d, row, col)
record in the rows, columns, boxes and board
-remove_number (d, row, col)
the opposite of place_num
-place_next_num(row, col)
to see if the current (row, col) is the last cell; 
if yes, then mark as solved
if no, go to the next cell (use backtrack)
-backtrack(row, col)
consider putting a number in (row, col);
if empty, iterate all numbers, use could_place, place_num, place_next_num (backtrack, recursion), until the last cell, if not solved, remove_number, try another number in the iteration;
else: use place_next_num

### new
- defaultdict: like dictionaries, but never raise KeyErrors, provide defulat values for nonexistent keys
rows = [defaultdict(int) for i in range(N)]
rows = [defaultdict(set) for i in range(N)]
a list of dictionaries, int-> default value for nonexistent key is 0
- lambda function to compute the box index<br/>
![](https://user-images.githubusercontent.com/102558337/171506708-eabb5b29-98d2-45b1-a113-d88bc974b0b6.png)

//: integer division 
box_idx = lambda r, c: (r//3)*3+c//3

## 51. N-Queens
### variables
set: quick look up
for a given row:
- cols: a set to store and look up column index
- diagonals: a set to store and look up diagonal indexes: row-col
- anti-diagonals: anti-diagonal indexes: row+col
### functions
- create_board(state)  
turn a 2d array state into a list of strings (the answer format)
- backtrack(row, diagonals, anti-diagonals, cols, state)  
**base case:** finished placing queens in n rows, add to answer  
**for each** col in this row:  
iterate over all columns to try placing the queen,  
if not placeable for this col, continue  
if placeable for this col, record in the cols, diagonals, anti-diagonals, change in the state  
**call itself - recursion:** move on to the next row with the updated board state  
**restore:** keep the state the same for the next col in iteration  
```
    def solveNQueens(self, n: int) -> List[List[str]]:
        
        def create_board(state):
            board = []
            for row in state:
                board.append("".join(row))
            return board
        
        def backtrack(row, cols, diagonals, anti_diagonals, state):
            """
            for the given row, return if finished placing n queens;
            continue exploring for row+1 if not;
            restore
            """
            # base case
            if row == n:
                ans.append(create_board(state))
                return
            
            for col in range(n):
                # if this col is not placeable
                if (col in cols or col in diagonals or col in anti_diagonals):
                    continue
                # if placeable
                cols.add(col)
                diagonals.add(row-col)
                anti-diagonals.add(row+col)
                state[row][col] = "Q"
                
                backtrack(row+1, cols, diagonals, anti_diagonals, state)
                
                # restore for the next col in the same level
                cols.remove(col)
                diagonals.remove(row-col)
                anti_diagonals.remove(row+col)
                state[row][col] = "."
                
        ans = []
        state = [["."]*n for _ in range(n)]
        backtrack(0, set(), set(), set(), state)
        return ans
```
# BFS
## 127. Word Ladder
### edge cases first
### adjacency list (graph)
- a map (defaultdict): intermediate word -> all words a letter from it
### queue
- while queue:
- current = queue.popleft()
- for_ in _ (iterate to find the next node)
- check if it's the answer
- check if vistied
- else put them in the queue, append
### visited
- make sure not revisit
### First
```
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:

            # edge cases
            if not beginWord or not endWord or endWord not in wordList:
                return 0

            L = len(beginWord)

            # create an adjacency list
            interm_map = defaultdict(list)
            # O(L*N)
            for word in wordList:
                for i in range(L):
                    interm_word = word[:i]+"*"+word[i+1:]
                    interm_map[interm_word].append(word)

            queue = collections.deque()
            level = 1
            queue.append((beginWord, level))
            # keep record of visited
            visited = set(beginWord)

            while queue:
                cur, level = queue.popleft()

                # search next level
                for i in range(L):
                    interm_word = cur[:i]+"*"+cur[i+1:]
                    for word in interm_map[interm_word]:
                        # if it's endWord
                        if word == endWord:
                            return level + 1

                        if word in visited:
                            continue

                        queue.append((word, level+1))
                        visited.add(word)

                    # although we have visited to ensure not returning to the same node
                    # empty the list to save the search in later iteration
                    interm_map[interm_word] = []
            #if not found
            return 0
```
### new
- use intermediate words like 'h\*t' as keys
- be careful about the 'level', where to add, or keep it when adding to the queue
### perhaps more genenral
```
       while queue:
            # for nodes in the same level
            for  i in range(len(queue)):
                cur = queue.popleft()

                for word in adj_map[cur]:
                    # check if it's destination
                    if word == endWord:
                        return level + 1
                    # check if visited
                    if word in visited:
                        continue

                    queue.append(word)
                    visited.add(word)
            # add level after all nodes in the same level have been popped    
            level += 1
```
### Second
