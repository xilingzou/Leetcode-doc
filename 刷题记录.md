# Search
## 37.Sudoku Solver
### variables
- rows: a list of defaultdict, for dictionary rows[row_idx], record whether key 'num' in the dictionary
- columns
- boxes
- solved: nonlocal boolean, whether solved
- board (given)
(rows, columns, boxes need to be initialized according to the table using place_num())

### functions
- could_place(d, row, col)
check if d can be placed at (row, col)
-place_num(d, row, col)
record in the rows, columns, boxes and board
-remove_number (d, row, col)
the opposite of place_num
-place_next_num(row, col)
to see if the current (row, col) is the last cell; 
if yes, then mark as solved
if no, go to the next cell (use backtrack)
-backtrack(row, col)
consider putting a number in (row, col);
if empty, iterate all numbers, use could_place, place_num, place_next_num (backtrack, recursion), until the last cell, if not solved, remove_number, try another number in the iteration;
else: use place_next_num

### new
- defaultdict: like dictionaries, but never raise KeyErrors, provide defulat values for nonexistent keys
rows = [defaultdict(int) for i in range(N)]
rows = [defaultdict(set) for i in range(N)]
a list of dictionaries, int-> default value for nonexistent key is 0
- lambda function to compute the box index<br/>
![](https://user-images.githubusercontent.com/102558337/171506708-eabb5b29-98d2-45b1-a113-d88bc974b0b6.png)

//: integer division 
box_idx = lambda r, c: (r//3)*3+c//3

## 51. N-Queens
### variables
set: quick look up
for a given row:
- cols: a set to store and look up column index
- diagonals: a set to store and look up diagonal indexes: row-col
- anti-diagonals: anti-diagonal indexes: row+col
### functions
- create_board(state)  
turn a 2d array state into a list of strings (the answer format)
- backtrack(row, diagonals, anti-diagonals, cols, state)  
**base case:** finished placing queens in n rows, add to answer  
**for each** col in this row:  
iterate over all columns to try placing the queen,  
if not placeable for this col, continue  
if placeable for this col, record in the cols, diagonals, anti-diagonals, change in the state  
**call itself - recursion:** move on to the next row with the updated board state  
**restore:** keep the state the same for the next col in iteration  


